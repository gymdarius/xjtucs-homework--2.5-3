事务(Transaction)是数据库系统中故障恢复和并发控制的基本单位

事务是数据库环境下由一组操作序列组成的逻辑工作单元，是一个不可分割的整体

commit 提交事务所有操作，将事务的修改存放到磁盘中

rollback 回滚，撤销事务的所有操作，回到事务还没有执行时的状况

**事务的四个特性**

1. A atomicity 原子性（事务中包括的操作要么都做要么都不做）
2. C consistency 一致性（事务执行的结果必须是让数据库从一个一致状态变为另一个一致状态）
3. I isolation 隔离性（一个事务的执行不能被其他事务干扰）
4. D duration 持久性（一个事务一旦提交，其对数据库的影响应该是永久性的）

事务的操作

1. read(X)：从数据库中将数据对象X读入事务的一个局部缓冲区
2. write(X):从事务的缓冲区中将数据对象写入数据对象X

## SQL的事务管理

### 隔离级别

读未提交：允许读未提交的记录，出现读脏数据

读已提交：只允许读已提交的记录，出现不可重复读、幻象行问题

可重复读：只允许读已提交的记录，并要求一个事务对同一记录的两次读取之间，其他事务不能对该记录产生修改。

可串行化：允许事务与其他事务并发执行，但系统必须保证调度是可串行化的

## 故障分类

事务故障：影响单个事务正常运行的任何事件。是事务内部的错误，不会影响到其他事务。和代码的编写有关。需要UNDO。

系统故障：是由DBMS的硬件/软件出现错误、断电。UNDO(未完成事务但其修改已经放入磁盘中)，REDO(已完成事务但其修改还没有写入磁盘中)

介质故障：由外存损坏引起的故障，需要根据事务日志进行REDO操作

## 故障恢复

基本原理：冗余

动态（联机）备份、静态（脱机）备份

增量（只备份上一次备份后更新的）备份、海量备份（每次备份全部）

日志：记录为单位、数据库为单位

日志：登记的次序必须和执行的次序一致。必须先写日志，再写数据库

**主要是理解数据日志、数据文件和commit日志的写入时机。时机不同，恢复方法不同**

即时更新：

<T,begin>

flush	将日志从缓存区写入磁盘

output	将数据从缓存区写入磁盘

<T,commit>

延时更新

<T,begin>

flush	将日志从缓存区写入磁盘

<T,commit>

output	将数据从缓存区写入磁盘

理解：

+ 事务故障：退回到出现故障的这个事务的begin处，只用UNDO，恢复时反向扫描。
+ 介质故障：从上一个备份点开始，只进行REDO。静态备份可以不需要日志，加日志的话只需要REDO log动态备份的话需要日志，REDO log和UNDO log都需要
+ 系统故障：一些尚未完成的事务的结果可能已送入物理数据库（只出现在即时更新）、有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中（只出现在延时更新）。如果数据库写日志采用即时更新，则在这一部分只进行UNDO、反之只进行REDO。正向扫描找REDO、找UNDO，反向扫描做UNDO、正向扫描做REDO.
+ 在做UNDO/REDO时，扫描遇到的每一个事务都与UNDO/REDO LIST进行比较

##### 参考资料上是这样讲的，帮助理解：

###### UNDO日志

**类似即时更新**

![image-20240609143717871](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240609143717871.png)

###### REDO日志

**延时更新的一种**

![image-20240609143915778](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240609143915778.png)

###### UNDO/REDO日志

**在一个事务对一个内存块的多个变量有操作时很有用**

![image-20240609144133913](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240609144133913.png)

### 检查点

重新开始文件：记录各个检查点在日志中的地址

![image-20240618200623709](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240618200623709.png)

事务的不同状态关键看什么时候出现的commit

![image-20240618200736168](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240618200736168.png)

![image-20240618200744429](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240618200744429.png)





## 并发控制

### 3种锁的类型

X锁(独占锁、写锁)、S锁(共享锁、读锁)、U锁(用于更新值，在写入时用X锁，其余时候用S锁)

### 3级加锁协议

依次解决 丢失更新、读脏数据、不可重复读 问题

### 2段锁协议 2PL

第一阶段获得封锁、第二阶段释放封锁

> 两段锁协议 应该是可能出现死锁的吧，因为它是不考虑锁是不是都能获得，就去获得锁，比如有A、B、C三个锁需要获得，它依次获得A、B锁，但是C锁无法获得就会等待，进而产生死锁。然而防止死锁的一次封锁法只有在判断A、B、C三个锁都能获得之后才会去申请获得锁

### 活锁

其实就是饥饿，解决的方法是先来先服务

### 死锁

**一次封锁法**：降低了系统的并发性

**顺序封锁法：**难以预先确定封锁顺序

#### 死锁预防方法

##### 时间标记

每个事务开始时被赋予的随时间递增的数字，数字越小越老

![image-20240618165549263](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240618165549263.png)

![image-20240618165717467](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240618165717467.png)

##### 如何记忆

等待-死亡(年轻的自己回滚)

击伤(年老的击伤年轻的，使其回滚)-等待

一个事务申请资源，将该事务的年龄与占有资源的事务的年龄进行比较

第一个词是若年老的状态，第二个词若年轻的状态

#### 死锁的检测与解除

**检测**

超时法(误判、不能及时发现)

等待图法

**解除**

撤销一个处理死锁代价最小的事务

### 多粒度锁

显示封锁、隐式封锁(后裔)

#### 意向锁

意向锁的含义是如果对一个结点加意向锁，则说明该结点的下层结点将要被加锁；对任一结点加锁时，必须先对它的所有上层结点加意向锁。 

例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁。

![image-20240618172633969](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240618172633969.png)

锁的相容矩阵 看ppt p99

### 基于时间的并发控制

tr(X)：数据对象X的读时间标记

tw(X)：数据对象X的写时间标记

两个都是取所有读/写成功事务中最年轻的事务的时间标记

ts(T)：事务T的时间标记

![image-20240618173453132](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240618173453132.png)

不能读到未来的事务

![image-20240618173553776](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240618173553776.png)

不能改变未来的事务

**没有死锁，有活锁**

### 乐观并发控制

适用于以读为主的系统

读阶段：将数据读入私有执行空间，并进行更新，保留在私有执行空间中

检查阶段：判断可行性，（将更新操作应用于数据库，不会违反可串行性）

写阶段：根据检测结果，决定是否将实际的更新写入数据库