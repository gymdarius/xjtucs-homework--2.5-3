## 数据依赖

![image-20240617203422934](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617203422934.png)

R：关系模式

U：R的属性全集。U={A1,A2,Ai,An} Ai为R的一个属性。 X、Y、Z为U的一个真子集

关系的模式：关系的内涵

关系的实例r：关系的外延

### 函数依赖

决定子

+ 满足依赖的关系：依赖在模式的某个关系实例上成立
+ 模式上成立的依赖：依赖在模式的所有关系实例上都成立

函数依赖是指关系R模式的所有关系元组均应满足的约束条件,而不是关系模式中的某个或某些元组满足的约束条件

完全函数依赖

部分函数依赖

平凡函数依赖

传递函数依赖

**逻辑蕴含**

函数依赖集合的闭包：此计算是一个NP完全问题，无法表示完全。

### 函数依赖推理规则

![image-20240617204647178](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617204647178.png)

![image-20240617204759875](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617204759875.png)

### 逻辑导出

![image-20240617204824659](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617204824659.png)

### 属性集合的闭包

![image-20240617204851979](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617204851979.png)

可以算出。

### armstrong公理

![image-20240617204910183](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617204910183.png)

![image-20240617204957743](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617204957743.png)

### 函数依赖集合的等价覆盖

F和G的表达(扩张)能力一致

![image-20240617205350178](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617205350178.png)

![image-20240617205431049](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617205431049.png)

### 最小函数依赖集

![image-20240617205501546](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617205501546.png)

+ (2)F中的函数依赖的决定子都是最小的（即都是完全函数依赖）
+ (3)函数依赖不能有冗余的，比如同时存在(a->b,b->c,a->c)
+ 最小覆盖不唯一

得到最小函数依赖集的解题过程。

1. 让函数依赖右部均变为单属性
2. 让函数依赖的决定子向最简部分靠近，可能出现分支（去掉某几个属性都可以）。【考察左部不是单属性的函数依赖，消除多余属性】
3. 去除冗余的函数依赖

### 多值依赖MVD

看ppt更明白。p41![image-20240617210323245](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20240617210323245.png)

## 关系模式分解

应当既无损连接，又保持函数依赖

![image-20240617210824054](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617210824054.png)

若不是无损连接，则r的数量会变多

### 投影连接运算

### 无损连接的判定方法，ppt上的看懂了

**无损连接是必须的，可以保持函数依赖更好**

![image-20240617211538184](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617211538184.png)

### 保持函数依赖的分解

![image-20240617211915471](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617211915471.png)

![image-20240620212039961](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240620212039961.png)

## 关系模式的规范化

### 1NF

![image-20240617212138771](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617212138771.png)

任何一个包含在候选键中的属性被称为主属性

### 求关系模式上的全部候选键的方法

分成四个集合的那个 p83

### **2NF**

![image-20240617212446865](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617212446865.png)

#### 注意理解 非主属性对键的部分函数依赖。

主属性为 AB，如果函数依赖有B->C，则此关系模式存在非主属性对键的部分函数依赖，不满足2NF

### 3NF

![image-20240617212518937](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617212518937.png)

### BCNF

![image-20240617212558692](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617212558692.png)

![image-20240617212608341](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617212608341.png)

### 解题方法

判断BCNF是最快的：看每一个决定子是否包含候选键，若每一个都是，则为BCNF。

先BC，然后从低往高走（自己看），找到第一个不满足的就说，因为什么什么到不了该NF，所以最高到该NF的低一级NF

### 既无损连接又保持函数依赖的3NF分解算法

### 保证无损连接的BCNF分解算法

### 总结

![image-20240617214241968](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240617214241968.png)

1. 1NF解决了数据冗余和更新异常的问题。
2. 2NF解决了部分函数依赖引起的更新异常问题
3. 3NF解决了传递函数依赖引起的更新异常和删除异常问题
4. BCNF解决了主属性对候选键的部分和传递函数依赖问题，以及在特殊情况下2NF和3NF未能解决的更新异常问题
5. 4NF解决了多值依赖引起的插入异常和删除异常问题。