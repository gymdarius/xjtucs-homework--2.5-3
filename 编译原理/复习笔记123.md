![image-20240613200710252](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240613200710252.png)

![](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240613200710252.png)

#### 1编译概述

**解释器和编译器的区别：**

1. 概念上的不同（解释器是逐行翻译并直接执行，编译器是整段翻译然后执行）
2. 解释器的动态性较强，编译器的动态性较弱
3. 基于解释器执行 速度较慢、内存消耗较大。便于调试，利于人机交互

T型图

![image-20240623140211255](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623140211255.png)

词法分析,token流

语法分析,语法树

语法分析是格式上的错误，语义分析是含义上的错误

| 阶段                   | 源程序                        |
| ---------------------- | ----------------------------- |
| 词法分析               | 单词符号（Token流）           |
| **语法分析**           | **语法单位（语法树PARSE树）** |
| 语义分析与中间代码生成 | 中间表示                      |
| 优化                   | 优化的中间表示                |
| 目标代码生成           | 目标代码(汇编代码)            |

**Token分类：**

1. 标识符(用户定义的名字) identifier
2. 保留字/关键字 reserve word
3. 常数 constant
4. 界符/分隔符 delimiters
5. 运算符/操作符 operators

编译器前端：与源语言有关、与目标机器无关

阶段：词法分析、语法分析、语义分析与中间代码生成。部分优化。

编译器后端：与源语言无关、与目标机器有关

阶段：优化、目标代码生成

**冯诺依曼结构：**

1. 采用二进制形式表示数据和指令
2. 采用存储程序方式

**图灵机：**

格式：（当前状态单元，当前单元内容）->（下个状态单元，当前单元内容的修改值）要做的动作

#### 1形式语言概述

有穷自动机：是有限状态机器，通过状态之间的迁移来消耗掉输入串，以判定是否为自动机所接受。

正则表达式：`^`：开始,`$`：结束,`|`：或者 ,`+`：1次或多次,`*`：0次或多次,`{18}`：重复18次

形式文法：从一个特殊的符号出发，不断的应用产生式规则，从而产生一个符号串的集合

+ 可用一个四元组来表示。G={Vn, Vt，P，S}
+ Vn:非终结符号或变量的有限集合，表示了句子中不同的内容；Vt:终结符的有限集合，和Vn没有交集，是语句的实际内容；P:产生式规则集合（左边必须包含变量，右边可以是任意语句）；S：开始变量，必须是Vn的元素。Kleene星号的例子：{"ab", "c"}* = {ε, "ab", "c", "abab", "abc", "cab", "cc", "ababab", "ababc", "abcab", "abcc", "cabab", "cabc", "ccab", "ccc", ...}

**区分文法的类别 4种** 从低到高依次去看

![image-20240613203059547](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240613203059547.png)

+ 0型文法[短语文法]（左边有非终结符，右边有终结符。）限制最少，一般见到的文法都可以看作0型文法。0型文法的能力相当于图灵机
+ 1型文法[上下文有关文法]（式子左边可以有多个字符，但必须有一个非终结符；式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符且左边长度必须小于右边）{α->β均满足|α|<=|β|, 除了α->ε外；}
+ 2型文法[上下文无关文法]：式子左边必须是非终结符，然而一个终结符一个非终结符的组合不是一个非终结符，如Ab不是一个非终结符，但是两个非终结符的组合就是一个非终结符了，如AB就是行了；式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符
+ 3型文法[正规文法]：又分为左线性文法、右线性文法右线性文法：式子左边只能有一个字符，而且必须是非终结符；式子右边最多有二个字符。如果有二个字符必须是（终结符+非终结符）的格式，如果是一个字符，那么必须是终结符。左线性文法：式子左边只能有一个字符，而且必须是非终结符；式子右边最多有二个字符。如果有二个字符必须是（非终结符+终结符）的格式，如果是一个字符，那么必须是终结符。
+ 判断一组产生式规则集合采用何种文法的方式：从0到3，依次判断，所用的文法为最后一个满足的型号

符号、字母表、符号串、语言、问题

+ 字母表是符号的有穷集合
+ 符号串是字母表上的符号串，由该字母表中符号组成的长度有穷的序列。
+ 长度为0的符号串是空串，习惯上采用 e(episilon希腊字母)表示空串。字母表Σ上的符号串全集=Σ*。Σ上的语言是Σ 上符号串的集合，显然， Σ 上的语言是Σ *的一个子集。
+ 要求解的问题都是判定性的问题

#### 2DFA

![image-20240406201216609](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240406201216609.png)

Σ：sigma

乘积自动机

+ 判断状态之间的迁移
+ 判断有些状态是到不了的（不能从头到达/无法到达终止态）

DFA：给出转移表画出转移图

用自然语言描述DFA的语言L(A)，DFA定义的语言是**正则语言**

扩展转移函数：为了方便表示连续的转移，扩展转移函数υ 为 ῦ

+ 基础:    ῦ(q, ε) = q
+ 归纳： ῦ(q, wa) = υ(ῦ(q, w), a)

![image-20240613212404256](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240613212404256.png)

###### 总结

必须以a结尾的串

![image-20240623155957019](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623155957019.png)

首尾字母必须一样的串

![image-20240623160052602](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623160052602.png)

{0,1}上含有子串11的串

![image-20240623160209288](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623160209288.png)

字母表{0, 1}上的DFA 接受所有最多含有三个1的串(空串也是合法的)

![image-20240623160237396](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623160237396.png)

{0,1}上的，含有偶数个0和偶数个1 的串的全集，是正则语言。

![image-20240623160417521](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623160417521.png)

{0,1}上不包含一对1且中间被奇数个0隔开的任何串。（排除包含的情况：感觉一定要让整个串进入一个死循环中，即输入0/1都一直是一个值）

![image-20240623160450432](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623160450432.png)

L={w ∈{0,1}*|w 看作二进制数的话能被5整除}

![image-20240623160737227](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623160737227.png)

{0, 1}上以01结尾的串

![image-20240623162708100](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623162708100.png)

NFA与DFA的不同

+ DFA：从同一个状态射出的带有相同标记的箭弧最多有一条。
+ NFA：从同一个状态射出的带有相同标记的箭弧可以有多条（NFA）。
+ ε-NFA：有ε-转移的NFA。
+ ε-转移：状态间的ε-转移不消耗输入符号。

#### 2NFA

![image-20240623163146609](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623163146609.png)

为空表示进入死状态

![image-20240623163231277](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623163231277.png)

更新活动状态集：当前活动状态集中每一个状态和转移函数结合生成的新状态，将新状态并起来

![image-20240623163558934](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623163558934.png)

**定理：语言L为某个DFA接受当且仅当它为某个NFA接受**

**定理：若 DFA D 是从NFA N 通过子集构造法构造而成，则L(D ) = L(N )。**

**定理：语言L 被某个ε-NFA接受当且仅当L 为某个DFA接受**

NFA转DFA：**子集法**

初始状态 输入分别为0和1，得到两个状态集合，将之前未出现的状态集合加进来，循环输入0和1.直到某次输入结束后没有产生新的状态集合，并且所有状态集合的输入输出结果均已得出。则结束。

初始状态作为初始状态，所有包含接受状态的状态集合作为结束状态

**ε-转移与ε-NFA**

+ ε-转移：不消耗输入符号发生状态转移用符号ε标记
+ ε-转移。含有ε-转移的NFA就是ε-NFA

带空转(e)，状态转移函数会变为：Q*{EUe}->Q

**状态q 的ε-闭包**，记为ω(q) ，指自身以及经过连续ε-转移所能到达的状态的集合（不消耗输入）。一定包含自身

![image-20240623165300763](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623165300763.png)

**消除ε-转移（转为NFA）**

先算出每一个状态的闭包，再计算新的NFA状态表时，用闭包中的状态、输入结合原本的状态表，得到新的状态表中的值

![image-20240623165837641](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623165837641.png)

![image-20240623180935153](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623180935153.png)

+ 注意一开始加入的是q0的闭包。
+ 之后去判断每一个状态对不同输入串产生的下一个状态时，要根据原来输入0、1得到的结果，然后去求闭包，不再考虑e串那一列了。
+ 注意根据一开始的状态表算出的集合还要去求闭包，才是最后的结果









#### 3RE

正则表达式：类似于算术表达式的代数式子，作为与符号串进行匹配的模式来定义语言，多用做文本匹配模式。

语言的**连接**、**并**运算

![image-20240623185055240](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623185055240.png)

![image-20240623185229690](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623185229690.png)

![image-20240409192915713](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240409192915713.png)

**编译原理学的正则表达式和常用的正则表达式不完全一样**

##### **典型RL：**

1. 该语言元素不含子串00 ：(1+01)\*(ε+0) / 1\*(011\*)\*(ε + 0)
2. 该语言元素有偶数个0，奇数个1：
3. 该语言元素有偶数个0，或者有奇数个1：`(1*01*01*)*+(0*10*)(0*10*10*)*`
4. 

![image-20240623200530995](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623200530995.png)

**RE转换为NFA的方法：**

![image-20240623201010441](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623201010441.png)

![image-20240623201020423](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623201020423.png)

**DFA转换为RE**

具体方法是 RE转换为NFA的方法的逆用

**GNFA（通用NFA）**

+ 只有一个接受状态
+ 没有射入到初始状态的弧
+ 没有从接受状态射出的弧
+ 弧上标记采用正则表达式作标记

![image-20240623201719478](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623201719478.png)

NFA弧上标记都被当作正则表达式，再检查没有射入初始状态的弧和没有从接受状态射出的弧，即成为GNFA。

NFA转化为GNFA：在开始状态和唯一的接受状态两边添加一个e转移，形成新的开始状态和接受状态，以满足GNFA的定义

![image-20240623201821547](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623201821547.png)

UNIX中的正则表达式 第三章REp50

正则表达式中的代数规律 第三章REp54

#### 3RL

语言L是正则语言，当且仅当存在Σ上的DFA、NFA、ε-NFA或者RE（统称为语言识别器），接受L。

正则语言具有**封闭性**

**定理3.5** 如果L是字母表Σ上的正则语言，那么补集L^c^=Σ^*^ -L也是正则语言（注意： ∁Σ\*L=LC =Σ*-L ）

![image-20240406202037586](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240406202037586.png)

简化型DFA和完全型DFA

**定理3.6** 如果L和M都是正则语言，那么L∩M 也是

**注意：Q^C^ 表示集合Q的补集**

一个式子：υ((p, q), a) = (υL(p, a), υM(q, a))

![image-20240406202743111](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240406202743111.png)

**定理3.7** 如果L是正则语言，则LR也是

**泵引理**

![image-20240406203937352](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240406203937352.png)

对第一行不清楚

![image-20240406205011661](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240406205011661.png)

RL的有限性

![image-20240623214212312](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623214212312.png)

![image-20240623214221566](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240623214221566.png)

**DFA的最小化**：把一个DFA转换为等价的最小状态集DFA

语言识别器(DFA,NFA,正则表达式)的等价性指它们定义的语言相同。

最小化DFA有共同的特征：它的任意两个状态都是可区分的（即该DFA中不存在等价状态）

**定义3.2**：状态p和q是可区分的，若存在一个测试串w，使得v'(p,w)和v'(q,w)恰有一个是接受状态。



等价状态(不可区分状态)：对任意串w∈Σ*，v'(p,w)∈F当且仅当v'(q,w)∈F，那么状态q和p是等价的。 



最小化DFA的填表算法

![image-20240408150201023](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240408150201023.png)

用判断可区分状态的定义3.2理解，直到再也找不到可区分的两个状态了，剩下的所有二元状态组即为等价对。最初始被标记的元素就是一个是接受状态，一个是不接受状态。



**这种找等价对的题是会考的 3~5分**

**定理3.8：**如果通过填表算法不能区分DFA的两个状态，那么它们是等价的

**采用Hopcroft算法最小化**

DFA (Q,Σ,υ,q0,F)

第一步：将Q分为两部分，一部分是终结状态，一部分是其他状态。

![image-20240408153650337](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240408153650337.png)

第二步：划分G2(其他状态)

![image-20240408153716653](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240408153716653.png)

并按照其输入0、1之后的结果分为更多的部分，按照相同类型划分为一类。

![image-20240408153802677](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240408153802677.png)

第三步：由于新的划分导致原来的分组可能又会产生新的变化，进行进一步调整，使每个分组内所有状态输入0、1串后得到的输入是完全一致的。

![image-20240408153845209](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240408153845209.png)

对所有分组进行调整后，就得到了最小化结果（检查一致性并构建转移表）

![image-20240408154002291](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240408154002291.png)

**比较**

![image-20240408154237509](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20240408154237509.png)

